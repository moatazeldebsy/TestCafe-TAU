"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCallsiteForError = exports.getCallsiteForMethod = void 0;
const callsite_record_1 = __importDefault(require("callsite-record"));
const stack_cleaning_hook_1 = __importDefault(require("./stack-cleaning-hook"));
const source_map_support_1 = require("source-map-support");
const STACK_TRACE_LIMIT = 2000;
function getCallsite(options) {
    const originalStackCleaningEnabled = stack_cleaning_hook_1.default.enabled;
    const originalStackTraceLimit = Error.stackTraceLimit;
    stack_cleaning_hook_1.default.enabled = false;
    Error.stackTraceLimit = STACK_TRACE_LIMIT;
    const callsiteRecord = callsite_record_1.default(options);
    Error.stackTraceLimit = originalStackTraceLimit;
    stack_cleaning_hook_1.default.enabled = originalStackCleaningEnabled;
    return callsiteRecord;
}
function getCallsiteForMethod(methodName, typeName) {
    return getCallsite({ byFunctionName: methodName, typeName, processFrameFn: source_map_support_1.wrapCallSite });
}
exports.getCallsiteForMethod = getCallsiteForMethod;
function getCallsiteForError(error, isCallsiteFrame) {
    // NOTE: "source-map-support" process this kind of error automatically, cause
    // in this case there is an appeal to "err.stack" inside "callsite-record" which
    // provokes wrapping of frames, so there is no need to specify "processFrameFn".
    return getCallsite({ forError: error, isCallsiteFrame });
}
exports.getCallsiteForError = getCallsiteForError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LWNhbGxzaXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Vycm9ycy9nZXQtY2FsbHNpdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsc0VBQW1EO0FBQ25ELGdGQUFzRDtBQUN0RCwyREFBa0Q7QUFFbEQsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUM7QUFFL0IsU0FBUyxXQUFXLENBQUUsT0FBTztJQUN6QixNQUFNLDRCQUE0QixHQUFHLDZCQUFpQixDQUFDLE9BQU8sQ0FBQztJQUMvRCxNQUFNLHVCQUF1QixHQUFRLEtBQUssQ0FBQyxlQUFlLENBQUM7SUFFM0QsNkJBQWlCLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztJQUNsQyxLQUFLLENBQUMsZUFBZSxHQUFPLGlCQUFpQixDQUFDO0lBRTlDLE1BQU0sY0FBYyxHQUFHLHlCQUFvQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRXJELEtBQUssQ0FBQyxlQUFlLEdBQU8sdUJBQXVCLENBQUM7SUFDcEQsNkJBQWlCLENBQUMsT0FBTyxHQUFHLDRCQUE0QixDQUFDO0lBRXpELE9BQU8sY0FBYyxDQUFDO0FBQzFCLENBQUM7QUFFRCxTQUFnQixvQkFBb0IsQ0FBRSxVQUFVLEVBQUUsUUFBUTtJQUN0RCxPQUFPLFdBQVcsQ0FBQyxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxpQ0FBWSxFQUFFLENBQUMsQ0FBQztBQUMvRixDQUFDO0FBRkQsb0RBRUM7QUFFRCxTQUFnQixtQkFBbUIsQ0FBRSxLQUFLLEVBQUUsZUFBZTtJQUN2RCw2RUFBNkU7SUFDN0UsZ0ZBQWdGO0lBQ2hGLGdGQUFnRjtJQUNoRixPQUFPLFdBQVcsQ0FBQyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQztBQUM3RCxDQUFDO0FBTEQsa0RBS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlQ2FsbHNpdGVSZWNvcmQgZnJvbSAnY2FsbHNpdGUtcmVjb3JkJztcbmltcG9ydCBzdGFja0NsZWFuaW5nSG9vayBmcm9tICcuL3N0YWNrLWNsZWFuaW5nLWhvb2snO1xuaW1wb3J0IHsgd3JhcENhbGxTaXRlIH0gZnJvbSAnc291cmNlLW1hcC1zdXBwb3J0JztcblxuY29uc3QgU1RBQ0tfVFJBQ0VfTElNSVQgPSAyMDAwO1xuXG5mdW5jdGlvbiBnZXRDYWxsc2l0ZSAob3B0aW9ucykge1xuICAgIGNvbnN0IG9yaWdpbmFsU3RhY2tDbGVhbmluZ0VuYWJsZWQgPSBzdGFja0NsZWFuaW5nSG9vay5lbmFibGVkO1xuICAgIGNvbnN0IG9yaWdpbmFsU3RhY2tUcmFjZUxpbWl0ICAgICAgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG5cbiAgICBzdGFja0NsZWFuaW5nSG9vay5lbmFibGVkID0gZmFsc2U7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICAgICA9IFNUQUNLX1RSQUNFX0xJTUlUO1xuXG4gICAgY29uc3QgY2FsbHNpdGVSZWNvcmQgPSBjcmVhdGVDYWxsc2l0ZVJlY29yZChvcHRpb25zKTtcblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCAgICAgPSBvcmlnaW5hbFN0YWNrVHJhY2VMaW1pdDtcbiAgICBzdGFja0NsZWFuaW5nSG9vay5lbmFibGVkID0gb3JpZ2luYWxTdGFja0NsZWFuaW5nRW5hYmxlZDtcblxuICAgIHJldHVybiBjYWxsc2l0ZVJlY29yZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENhbGxzaXRlRm9yTWV0aG9kIChtZXRob2ROYW1lLCB0eXBlTmFtZSkge1xuICAgIHJldHVybiBnZXRDYWxsc2l0ZSh7IGJ5RnVuY3Rpb25OYW1lOiBtZXRob2ROYW1lLCB0eXBlTmFtZSwgcHJvY2Vzc0ZyYW1lRm46IHdyYXBDYWxsU2l0ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENhbGxzaXRlRm9yRXJyb3IgKGVycm9yLCBpc0NhbGxzaXRlRnJhbWUpIHtcbiAgICAvLyBOT1RFOiBcInNvdXJjZS1tYXAtc3VwcG9ydFwiIHByb2Nlc3MgdGhpcyBraW5kIG9mIGVycm9yIGF1dG9tYXRpY2FsbHksIGNhdXNlXG4gICAgLy8gaW4gdGhpcyBjYXNlIHRoZXJlIGlzIGFuIGFwcGVhbCB0byBcImVyci5zdGFja1wiIGluc2lkZSBcImNhbGxzaXRlLXJlY29yZFwiIHdoaWNoXG4gICAgLy8gcHJvdm9rZXMgd3JhcHBpbmcgb2YgZnJhbWVzLCBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIHNwZWNpZnkgXCJwcm9jZXNzRnJhbWVGblwiLlxuICAgIHJldHVybiBnZXRDYWxsc2l0ZSh7IGZvckVycm9yOiBlcnJvciwgaXNDYWxsc2l0ZUZyYW1lIH0pO1xufVxuIl19